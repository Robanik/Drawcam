<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Hand Max Tracker</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }
</style>
</head>
<body>
<video id="video" autoplay style="display:none;"></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>

<script>
let video = document.getElementById('video');
let scene, camera, renderer;
let handLines = [];
const smoothing = 0.5; // сглаживание

// Индексы костей (MediaPipe hand landmarks)
const connections = [
  [0,1],[1,2],[2,3],[3,4],      // Большой палец
  [0,5],[5,6],[6,7],[7,8],      // Указательный
  [0,9],[9,10],[10,11],[11,12], // Средний
  [0,13],[13,14],[14,15],[15,16], // Безымянный
  [0,17],[17,18],[18,19],[19,20] // Мизинец
];

async function setupCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
  video.srcObject = stream;
  return new Promise(resolve => { video.onloadedmetadata = () => resolve(video); });
}

function initThree() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 10);
  camera.position.z = 0.7;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(3840, 2160); // 4K
  document.body.appendChild(renderer.domElement);

  const material = new THREE.LineBasicMaterial({ color: 0xffffff });
  
  for (let i = 0; i < connections.length; i++) {
    const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    const line = new THREE.Line(geometry, material);
    handLines.push(line);
    scene.add(line);
  }
}

// Сглаживание
function smoothPosition(oldPos, newPos, alpha=smoothing) {
  return oldPos.map((v, i) => v*(1-alpha) + newPos[i]*alpha);
}

async function main() {
  await setupCamera();
  video.play();
  initThree();

  const model = await handpose.load();
  const oldPositions = Array(21).fill([0,0,0]);

  async function animate() {
    requestAnimationFrame(animate);

    const predictions = await model.estimateHands(video, true);

    if (predictions.length > 0) {
      const landmarks = predictions[0].landmarks;

      // Сглаживание координат
      for (let i=0;i<21;i++){
        const smoothed = smoothPosition(oldPositions[i], landmarks[i]);
        oldPositions[i] = smoothed;
      }

      // Обновляем линии
      for (let i=0;i<connections.length;i++){
        const [a,b] = connections[i];
        const line = handLines[i];
        const positions = line.geometry.attributes.position.array;

        positions[0] = (oldPositions[a][0]-640)/640; // нормализация X
        positions[1] = -(oldPositions[a][1]-360)/360; // нормализация Y
        positions[2] = -oldPositions[a][2]/200; // Z глубина

        positions[3] = (oldPositions[b][0]-640)/640;
        positions[4] = -(oldPositions[b][1]-360)/360;
        positions[5] = -oldPositions[b][2]/200;

        line.geometry.attributes.position.needsUpdate = true;
      }
    }

    renderer.render(scene, camera);
  }

  animate();
}

main();
</script>
</body>
</html>
